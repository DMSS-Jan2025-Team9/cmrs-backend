# ✅ Security (DevSecOps)
# Static code analysis using SonarQube
# Dependency vulnerability scanning with OWASP Dependency-Check

# ✅ CI (Build and test)
# Build Docker image
# Run JUnit tests inside the Docker container
# Push Docker image to ECR
# Scan Docker image in ECR and access scan results

# ✅ CD (Deploy)
# Prepare ECS task definition with updated image
# Deploy to ECS and monitor rollout

name: DevSecOps CI/CD Pipeline for releases

on:
  push:
    branches:
      - feature/devsecops
      - "release/*" # This triggers on any branch starting with "release/"
    paths:
      - "usermanagement/**"
      - "coursemanagement/**"
      - "courseregistration/**"
      - "notificationservice/**"
      - "courserecommendation/**"
      - ".github/workflows/devsecops.yml"
      - ".aws/**"

env:
  AWS_REGION: ap-southeast-1
  ECR_REPOSITORY: ecr-cmrs
  ECS_CLUSTER: cmrs-ecs-cluster

jobs:
  detect-changes:
    runs-on: self-hosted # use self hosted runner
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch origin main
        run: git fetch origin main

      - name: Get changed folders
        id: set-matrix
        run: |
          # Get list of changed files compared to stable release branch
          CHANGED=$(git diff --name-only origin/main...HEAD)
          echo "Changed files:"
          echo "$CHANGED"

          # Define service config
          SERVICES='[
            {"name":"user-management", "path":"usermanagement", "task-def":".aws/user-management-task.json", "container-name":"user-management", "ecs-service":"user-management", "ecr":"ecr-cmrs-user-management"},
            {"name":"course-management", "path":"coursemanagement", "task-def":".aws/course-management-task.json", "container-name":"course-management", "ecs-service":"course-management", "ecr":"ecr-cmrs-course-management"},
            {"name":"course-registration", "path":"courseregistration", "task-def":".aws/course-registration-task.json", "container-name":"course-registration", "ecs-service":"course-registration", "ecr":"ecr-cmrs-course-registration"},
            {"name":"notification", "path":"notificationservice", "task-def":".aws/notification-task.json", "container-name":"notification", "ecs-service":"notification", "ecr":"ecr-cmrs-notification"},
            {"name":"course-recommendation", "path":"courserecommendation", "task-def":".aws/course-recommendation-task.json", "container-name":"course-recommendation", "ecs-service":"course-recommendation", "ecr":"ecr-cmrs-course-recommendation"}
          ]'

          # Exclude migration paths from the list of changes
          EXCLUDED_PATHS=('usermanagement/DBScript/migration/**' 'coursemanagement/DBScript/migration/**' 'courseregistration/DBScript/migration/**' 'notificationservice/DBScript/migration/**' 'courserecommendation/DBScript/migration/**')

          # Filter out the paths we don't want to trigger deployments for
          CHANGED=$(echo "$CHANGED" | grep -v -E "$(IFS=\|; echo "${EXCLUDED_PATHS[*]}")")
          echo "Filtered changed files (excluding migrations):"
          echo "$CHANGED"

          # If deploy-app.yml changed, deploy all services
          if echo "$CHANGED" | grep -q ".github/workflows/deploy-app.yml"; then
            echo "Workflow file changed. Triggering all services."
            echo "matrix=$(echo "$SERVICES" | jq -c)" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Get top-level folders that changed
          FOLDERS=$(echo "$CHANGED" | awk -F/ '{print $1}' | sort -u | jq -R . | jq -s .)
          echo "Changed folders: $FOLDERS"

          # Build matrix of affected services
          FILTERED=$(echo "$SERVICES" | jq --argjson changed "$FOLDERS" '[.[] | select($changed | index(.path))]')
          echo "matrix=$(echo "$FILTERED" | jq -c)" >> "$GITHUB_OUTPUT"

  build-and-deploy:
    name: Build and Deploy
    needs: detect-changes
    runs-on: self-hosted
    environment: dev
    timeout-minutes: 10

    if: ${{ fromJson(needs.detect-changes.outputs.matrix) != '[]' }}
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.matrix) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@0e613a0980cbf65ed5b322eb7a1e075d28913a83
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # Generate a timestamp for the image tag
          TIMESTAMP=$(date -u +"%Y%m%d_%H%M%S")
          IMAGE_REPO=${{ matrix.service.ecr }}
          IMAGE_TAG=$TIMESTAMP  # v1.0.0
          IMAGE_URI=$ECR_REGISTRY/$IMAGE_REPO:$IMAGE_TAG
          echo "Building image: $IMAGE_URI"

          # Build the Docker image and push it to ECR
          docker build -t $IMAGE_URI ${{ matrix.service.path }}

          # Push docker image to Amazon ECR
          docker push $IMAGE_URI
          echo "Pushing image: $IMAGE_URI"

          # Save the outputs
          echo "image=$IMAGE_URI" >> "$GITHUB_OUTPUT"
          echo "tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "repository=$IMAGE_REPO" >> "$GITHUB_OUTPUT"

      - name: Scan Docker image in ECR
        id: docker-scan
        uses: alexjurkiewicz/ecr-scan-image@v2.0.1
        with:
          repository: ${{ steps.build-image.outputs.repository }}
          tag: ${{ steps.build-image.outputs.tag }}

      # Access scan results in later steps
      - run: echo "${{ steps.docker-scan.outputs.total }} total vulnerabilities."

      - name: Set tag for ECR tasks
        id: set-tag
        env:
          proj: cmrs
          ecs-env: dev
          ecs-service-name: ${{ matrix.service.ecs-service }}
          version: ${{ steps.build-image.outputs.image }}
        run: |
          # Save the tags JSON manually for later use
          TAGS_JSON=$(printf '[{"key": "Environment", "value": "%s"}, {"key": "Project", "value": "%s"}, {"key": "Service", "value": "%s"}, {"key": "Version", "value": "%s"}]' \
            "$ecs-env" "$proj" "$ecs-service-name" "$version")

          echo "tags=$TAGS_JSON" >> "$GITHUB_OUTPUT"

      - name: Render new task definition
        id: render-task
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ${{ matrix.service.task-def }}
          container-name: ${{ matrix.service.container-name }}
          image: ${{ steps.build-image.outputs.image }}

      - name: Deploy to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        with:
          task-definition: ${{ steps.render-task.outputs.task-definition }}
          service: ${{ matrix.service.ecs-service }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: false
          enable-ecs-managed-tags: true
          wait-for-task-stopped: false
          run-task-tags: ${{ steps.set-tag.outputs.tags }}

  security-scan: # ➜ DevSecOps: Scan built images and dependencies
    name: Code & Dependency Scan
    needs: 
      - detect-changes
      - build-and-deploy
    runs-on: [self-hosted, cmrs-github-runner-03]
    timeout-minutes: 10

    if: ${{ fromJson(needs.detect-changes.outputs.matrix) != '[]' }}
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Static analysis using SonarQube (detects code-level vulnerabilities)
      - name: Run SonarQube Analysis
        working-directory: ./${{ matrix.service.path }}
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          # Run the SonarQube analysis with detailed test reports
          echo "Run the SonarQube analysis with detailed test reports"
          mvn -B org.sonarsource.scanner.maven:sonar-maven-plugin:sonar \
          -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }} \
          -Dsonar.projectKey=${{ matrix.service.path }} \
          -Dsonar.projectName='${{ matrix.service.path }}' \
          -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
          -Dsonar.tests=src/test \
          -Dsonar.test.inclusions=**/*Test.java \
          -Dsonar.java.coveragePlugin=jacoco \
          -Dsonar.verbose=true
          
      # Get SonarQube analysis report
      - name: Get SonarQube Analysis Report
        run: |
          SONAR_URL="${{ secrets.SONAR_HOST_URL }}"
          SONAR_TOKEN="${{ secrets.SONAR_TOKEN }}"
          PROJECT_KEY="${{ matrix.service.path }}"
          curl -u $SONAR_TOKEN: $SONAR_URL/api/issues/search?componentKeys=$PROJECT_KEY > sonar_report.json
          mv sonar_report.json ./sonar_report.json

      # Upload SonarQube report as artifact
      - name: Upload SonarQube report artifact
        uses: actions/upload-artifact@v4
        with:
          name: sonar-report
          path: ./sonar_report.json

      # Dependency analysis using OWASP Dependency-Check (detects vulnerable libraries)
      - name: Run OWASP Dependency-Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: "CMRS-Microservices"
          path: "."
          format: "HTML"
          out: "dependency-check-report"

      - name: Upload OWASP Report (for artifact review)
        uses: actions/upload-artifact@v4
        with:
          name: dependency-check-report
          path: dependency-check-report

  # cleanup-runs:
  #   needs: [build-and-deploy, security-scan]
  #   if: always()
  #   runs-on: self-hosted
  #   steps:
  #     - name: Delete older workflow runs
  #       uses: Mattraks/delete-workflow-runs@v2
  #       with:
  #         token: ${{ github.token }}
  #         repository: ${{ github.repository }}
  #         retain_days: 2
  #         keep_minimum_runs: 3
  #         delete_workflow_pattern: devsecops.yml
